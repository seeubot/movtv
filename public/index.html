<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide-react@latest"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
      body {
        font-family: 'Inter', sans-serif;
        color: #f8fafc;
        background-color: #000;
        scroll-behavior: smooth;
      }
      .focusable-item:focus {
        outline: 2px solid #fff;
        outline-offset: 2px;
      }
      .scrollable {
          -webkit-overflow-scrolling: touch;
      }
    </style>
</head>
<body class="bg-black text-white">
    <div id="root" class="min-h-screen"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        const { createRoot } = ReactDOM;
        const { Play, Pause, FastForward, FastRewind, Volume2, VolumeX, Volume1, Expand, ArrowLeft, Search, X } = lucideReact;

        // NOTE: The backend will replace this placeholder with the correct URL.
        const API_BASE_URL = window.location.origin + '/api';

        // This is the main App component that renders the entire UI
        const App = () => {
            const [movies, setMovies] = useState([]);
            const [series, setSeries] = useState([]);
            const [filteredMovies, setFilteredMovies] = useState([]);
            const [filteredSeries, setFilteredSeries] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [view, setView] = useState('home'); // 'home', 'video', 'series'
            const [currentVideo, setCurrentVideo] = useState(null);
            const [selectedSeries, setSelectedSeries] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [isControlsVisible, setIsControlsVisible] = useState(true);
            const [isPaused, setIsPaused] = useState(true);
            const [progress, setProgress] = useState(0);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [volume, setVolume] = useState(1);
            const [isMuted, setIsMuted] = useState(false);
            const videoRef = useRef(null);
            const containerRef = useRef(null);
            const focusHistory = useRef([]);
            const controlsTimeout = useRef(null);

            // Custom hook to handle showing/hiding video controls
            const showControls = useCallback(() => {
              if (view !== 'video') return;
              setIsControlsVisible(true);
              clearTimeout(controlsTimeout.current);
              controlsTimeout.current = setTimeout(() => {
                if (!isPaused) {
                  setIsControlsVisible(false);
                }
              }, 3000);
            }, [isPaused, view]);

            // Fetches data from the API on component mount
            useEffect(() => {
              const fetchData = async () => {
                setLoading(true);
                setError(null);
                try {
                  const [moviesResponse, seriesResponse] = await Promise.all([
                    fetch(`${API_BASE_URL}/movies`),
                    fetch(`${API_BASE_URL}/series`),
                  ]);

                  if (!moviesResponse.ok || !seriesResponse.ok) {
                    throw new Error('Failed to fetch data from API');
                  }

                  const moviesData = await moviesResponse.json();
                  const seriesData = await seriesResponse.json();

                  setMovies(moviesData);
                  setSeries(seriesData);
                  setFilteredMovies(moviesData);
                  setFilteredSeries(seriesData);
                } catch (err) {
                  console.error('Fetch error:', err);
                  setError('Failed to load data. Please try again.');
                } finally {
                  setLoading(false);
                }
              };
              fetchData();
            }, [API_BASE_URL]);

            // Handles search functionality
            useEffect(() => {
              const filterContent = async () => {
                setLoading(true);
                try {
                  const [moviesResponse, seriesResponse] = await Promise.all([
                    fetch(`${API_BASE_URL}/movies?search=${searchQuery}`),
                    fetch(`${API_BASE_URL}/series?search=${searchQuery}`),
                  ]);
                  const moviesData = await moviesResponse.json();
                  const seriesData = await seriesResponse.json();
                  setFilteredMovies(moviesData);
                  setFilteredSeries(seriesData);
                } catch (err) {
                  console.error('Search error:', err);
                  setError('Failed to search. Please try again.');
                } finally {
                  setLoading(false);
                }
              };

              const delayDebounceFn = setTimeout(() => {
                filterContent();
              }, 500);

              return () => clearTimeout(delayDebounceFn);
            }, [searchQuery, API_BASE_URL]);

            // Video player event handlers
            const handleVideoTimeUpdate = () => {
              const video = videoRef.current;
              if (video) {
                setProgress((video.currentTime / video.duration) * 100);
                setCurrentTime(video.currentTime);
              }
            };

            const handleVideoLoadedMetadata = () => {
              const video = videoRef.current;
              if (video) {
                setDuration(video.duration);
                video.volume = volume; // Set initial volume
              }
            };

            const handleVideoEnded = () => {
              closeVideoPlayer();
            };
            
            const handlePlayerMouseTouch = () => {
              showControls();
            };

            // Keyboard navigation logic
            const handleKeyDown = useCallback((e) => {
              // Prevent default scroll behavior for arrow keys
              if ([37, 38, 39, 40].includes(e.keyCode)) {
                e.preventDefault();
              }

              if (view === 'video') {
                handleVideoKeys(e);
              } else if (view === 'series') {
                handleSeriesModalKeys(e);
              } else {
                handleMainPageKeys(e);
              }
            }, [view, isPaused, showControls]);
            
            const handleMainPageKeys = (e) => {
              const focusables = Array.from(containerRef.current.querySelectorAll('.focusable-item'));
              const focusedEl = document.activeElement;
              const focusedIndex = focusables.indexOf(focusedEl);
              let targetEl = null;
            
              switch (e.keyCode) {
                case 39: // Right Arrow
                  if (focusedIndex < focusables.length - 1) targetEl = focusables[focusedIndex + 1];
                  break;
                case 37: // Left Arrow
                  if (focusedIndex > 0) targetEl = focusables[focusedIndex - 1];
                  break;
                case 40: // Down Arrow
                  targetEl = findVerticalFocus(focusedEl, 1, focusables);
                  break;
                case 38: // Up Arrow
                  targetEl = findVerticalFocus(focusedEl, -1, focusables);
                  break;
                case 13: // Enter
                case 32: // Space
                  if (focusedEl && focusedEl.classList.contains('focusable-item')) {
                    focusedEl.click();
                  }
                  break;
              }
            
              if (targetEl) {
                targetEl.focus();
              }
            };
            
            const findVerticalFocus = (focusedEl, direction, allItems) => {
              if (!focusedEl) return null;
              const focusedRect = focusedEl.getBoundingClientRect();
              let bestMatch = null;
              let minDistance = Infinity;
            
              for (const item of allItems) {
                const itemRect = item.getBoundingClientRect();
                if (direction > 0 && itemRect.top > focusedRect.bottom) {
                  const verticalDistance = itemRect.top - focusedRect.bottom;
                  const horizontalDistance = Math.abs((itemRect.left + itemRect.right) / 2 - (focusedRect.left + focusedRect.right) / 2);
                  const distance = verticalDistance + horizontalDistance * 0.5;
                  if (distance < minDistance) {
                    minDistance = distance;
                    bestMatch = item;
                  }
                } else if (direction < 0 && itemRect.bottom < focusedRect.top) {
                  const verticalDistance = focusedRect.top - itemRect.bottom;
                  const horizontalDistance = Math.abs((itemRect.left + itemRect.right) / 2 - (focusedRect.left + focusedRect.right) / 2);
                  const distance = verticalDistance + horizontalDistance * 0.5;
                  if (distance < minDistance) {
                    minDistance = distance;
                    bestMatch = item;
                  }
                }
              }
              return bestMatch;
            };
            
            const handleVideoKeys = (e) => {
              const video = videoRef.current;
              if (!video) return;

              switch (e.keyCode) {
                case 13: // Enter
                case 32: // Space
                  video.paused ? video.play() : video.pause();
                  break;
                case 39: // Right Arrow
                  video.currentTime += 10;
                  break;
                case 37: // Left Arrow
                  video.currentTime -= 10;
                  break;
                case 38: // Up Arrow
                  video.volume = Math.min(1, video.volume + 0.1);
                  setVolume(video.volume);
                  setIsMuted(false);
                  break;
                case 40: // Down Arrow
                  video.volume = Math.max(0, video.volume - 0.1);
                  setVolume(video.volume);
                  if (video.volume === 0) setIsMuted(true);
                  break;
                case 27: // Escape
                  closeVideoPlayer();
                  break;
              }
              showControls();
            };
            
            const handleSeriesModalKeys = (e) => {
              const focusables = Array.from(document.querySelectorAll('#series-modal .focusable-item'));
              const focusedEl = document.activeElement;
              const focusedIndex = focusables.indexOf(focusedEl);
              let targetEl = null;
            
              switch (e.keyCode) {
                case 40: // Down Arrow
                  if (focusedIndex < focusables.length - 1) targetEl = focusables[focusedIndex + 1];
                  break;
                case 38: // Up Arrow
                  if (focusedIndex > 0) targetEl = focusables[focusedIndex - 1];
                  break;
                case 13: // Enter
                case 32: // Space
                  if (focusedEl && focusedEl.classList.contains('focusable-item')) {
                    focusedEl.click();
                  }
                  break;
                case 27: // Escape
                  closeSeriesModal();
                  break;
              }
            
              if (targetEl) {
                targetEl.focus();
              }
            };

            useEffect(() => {
              document.addEventListener('keydown', handleKeyDown);
              return () => {
                document.removeEventListener('keydown', handleKeyDown);
              };
            }, [handleKeyDown]);

            // Play video function
            const playVideo = (url, item) => {
              focusHistory.current.push(document.activeElement);
              setCurrentVideo(item);
              setView('video');
              
              // Defer setting the source until the video element is available
              if (videoRef.current) {
                videoRef.current.src = url;
                videoRef.current.play();
                setIsPaused(false);
              }
            };

            // Close video player function
            const closeVideoPlayer = () => {
              if (videoRef.current) {
                videoRef.current.pause();
                videoRef.current.src = '';
              }
              setView('home');
              setCurrentVideo(null);
              if (focusHistory.current.length > 0) {
                focusHistory.current.pop().focus();
              }
            };

            // Open series modal function
            const openSeriesModal = async (seriesItem) => {
              setLoading(true);
              try {
                const response = await fetch(`${API_BASE_URL}/series/${seriesItem._id}`);
                if (!response.ok) throw new Error('Failed to fetch series details.');
                const seriesDetails = await response.json();
                setSelectedSeries(seriesDetails);
                focusHistory.current.push(document.activeElement);
                setView('series');
              } catch (err) {
                setError('Could not load series details.');
                console.error(err);
              } finally {
                setLoading(false);
              }
            };

            // Close series modal function
            const closeSeriesModal = () => {
              setView('home');
              setSelectedSeries(null);
              if (focusHistory.current.length > 0) {
                focusHistory.current.pop().focus();
              }
            };

            // Helper function to format time
            const formatTime = (seconds) => {
              const h = Math.floor(seconds / 3600);
              const m = Math.floor((seconds % 3600) / 60);
              const s = Math.floor(seconds % 60);
              const formatted = [
                h,
                m > 9 ? m : (h ? '0' + m : m || '0'),
                s > 9 ? s : '0' + s,
              ].filter(Boolean).join(':');
              return formatted;
            };
            
            const handleProgressClick = (e) => {
              const progressBar = e.currentTarget;
              const clickPosition = e.nativeEvent.offsetX / progressBar.offsetWidth;
              if (videoRef.current) {
                videoRef.current.currentTime = clickPosition * videoRef.current.duration;
              }
            };

            const handleTogglePlayPause = () => {
              const video = videoRef.current;
              if (video) {
                if (video.paused) {
                  video.play();
                  setIsPaused(false);
                } else {
                  video.pause();
                  setIsPaused(true);
                }
              }
              showControls();
            };
            
            const handleToggleMute = () => {
              const video = videoRef.current;
              if (video) {
                if (isMuted) {
                  video.muted = false;
                  setIsMuted(false);
                  video.volume = volume;
                } else {
                  video.muted = true;
                  setIsMuted(true);
                }
              }
            };

            // Main App content based on the current view state
            const renderContent = () => {
              switch (view) {
                case 'video':
                  return (
                    <div
                      className="fixed inset-0 z-50 bg-black flex items-center justify-center p-4 touch-none"
                      onMouseMove={handlePlayerMouseTouch}
                      onTouchStart={handlePlayerMouseTouch}
                    >
                      <button
                        onClick={closeVideoPlayer}
                        className="focusable-item bg-white bg-opacity-20 p-4 rounded-full text-white text-lg absolute top-4 left-4 z-[101]"
                        tabIndex="100"
                      >
                        <ArrowLeft />
                      </button>
                      <video
                        ref={videoRef}
                        className="w-full h-full object-contain bg-black"
                        onTimeUpdate={handleVideoTimeUpdate}
                        onLoadedMetadata={handleVideoLoadedMetadata}
                        onEnded={handleVideoEnded}
                        autoPlay
                        playsInline
                      />
                      {isPaused && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-center p-8 transition-opacity duration-300 z-50 bg-black bg-opacity-50">
                          {currentVideo?.thumbnail && (
                            <img src={currentVideo.thumbnail} alt="Thumbnail" className="w-48 h-auto rounded-lg shadow-xl mb-4"/>
                          )}
                          <h3 className="text-5xl font-bold text-white mb-2">{currentVideo?.title}</h3>
                          <p className="text-2xl text-gray-300">{currentVideo?.subtitle}</p>
                        </div>
                      )}
                      {isControlsVisible && (
                        <div className="absolute bottom-0 left-0 w-full p-8 transition-opacity duration-300 bg-gradient-to-t from-black via-black/80 to-transparent z-50">
                          <div className="flex items-center space-x-4 mb-4">
                            <span className="text-lg font-semibold">{formatTime(currentTime)}</span>
                            <div
                              className="flex-1 rounded-full overflow-hidden h-2 bg-white/30 focusable-item"
                              onClick={handleProgressClick}
                              tabIndex="101"
                            >
                              <div
                                className="h-full bg-white transition-all duration-100 ease-linear"
                                style={{ width: `${progress}%` }}
                              />
                            </div>
                            <span className="text-lg font-semibold">{formatTime(duration)}</span>
                          </div>
                          <div className="flex justify-center items-center space-x-8">
                            <button onClick={() => { videoRef.current.currentTime -= 10; showControls(); }} className="focusable-item bg-white/20 p-4 rounded-full text-white shadow-lg" tabIndex="102">
                              <FastRewind size={24} />
                            </button>
                            <button onClick={handleTogglePlayPause} className="focusable-item bg-white/20 p-5 rounded-full text-white shadow-lg" tabIndex="103">
                              {isPaused ? <Play size={32} /> : <Pause size={32} />}
                            </button>
                            <button onClick={() => { videoRef.current.currentTime += 10; showControls(); }} className="focusable-item bg-white/20 p-4 rounded-full text-white shadow-lg" tabIndex="104">
                              <FastForward size={24} />
                            </button>
                            <div className="flex items-center space-x-4">
                              <button onClick={handleToggleMute} className="focusable-item bg-white/20 p-4 rounded-full shadow-lg" tabIndex="105">
                                {isMuted ? <VolumeX /> : (volume > 0.5 ? <Volume2 /> : <Volume1 />)}
                              </button>
                              <input
                                type="range"
                                min="0"
                                max="1"
                                step="0.01"
                                value={isMuted ? 0 : volume}
                                onChange={(e) => {
                                  const newVolume = parseFloat(e.target.value);
                                  setVolume(newVolume);
                                  if (videoRef.current) {
                                    videoRef.current.volume = newVolume;
                                    setIsMuted(newVolume === 0);
                                  }
                                }}
                                className="focusable-item w-24 accent-white cursor-pointer"
                                tabIndex="106"
                              />
                            </div>
                            <button onClick={() => videoRef.current.requestFullscreen()} className="focusable-item bg-white/20 p-4 rounded-full text-white shadow-lg" tabIndex="108">
                              <Expand size={24} />
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  );
                
                case 'series':
                  if (!selectedSeries) return null;
                  return (
                    <div id="series-modal" className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-95 overflow-y-auto">
                      <div className="relative bg-zinc-900 rounded-lg p-8 w-full max-w-6xl max-h-[95vh] overflow-y-auto scrollable flex flex-col md:flex-row">
                        <button
                          onClick={closeSeriesModal}
                          className="focusable-item absolute top-4 right-4 text-white hover:text-gray-400 text-3xl"
                          tabIndex="200"
                        >
                          <X size={32} />
                        </button>
                        <div className="w-full md:w-1/3 flex-shrink-0 mb-6 md:mb-0 md:mr-8 text-center md:text-left">
                          <img
                            src={selectedSeries.thumbnail}
                            alt="Series Thumbnail"
                            className="rounded-lg shadow-xl mb-4 mx-auto md:mx-0"
                          />
                          <h2 className="text-4xl font-bold text-white mb-2">{selectedSeries.name}</h2>
                          <p className="text-lg text-gray-400">No description available.</p>
                        </div>
                        <div className="w-full md:w-2/3 max-h-full overflow-y-auto scrollable">
                          <div className="space-y-6">
                            {selectedSeries.seasons.sort((a, b) => a.seasonNumber - b.seasonNumber).map((season) => (
                              <div key={season.seasonNumber} className="border-b border-gray-700 pb-4 last:border-0">
                                <h3 className="text-2xl font-bold mb-4 text-white">Season {season.seasonNumber}</h3>
                                <div className="space-y-4">
                                  {season.episodes.sort((a, b) => a.episodeNumber - b.episodeNumber).map((episode) => (
                                    <div
                                      key={episode.episodeNumber}
                                      className="focusable-item flex items-center p-4 rounded-lg bg-zinc-800 hover:bg-zinc-700 transition-colors cursor-pointer"
                                      onClick={() => playVideo(episode.streamingUrl, { title: selectedSeries.name, thumbnail: episode.thumbnail, subtitle: `S${season.seasonNumber}E${episode.episodeNumber}: ${episode.title}`})}
                                      tabIndex="0"
                                    >
                                      <img
                                        src={episode.thumbnail || selectedSeries.thumbnail}
                                        alt={episode.title}
                                        className="w-32 h-20 object-cover rounded-md flex-shrink-0 mr-4"
                                      />
                                      <div>
                                        <p className="text-lg font-semibold text-white">E{episode.episodeNumber}: {episode.title}</p>
                                        <p className="text-sm text-gray-400">Stream now</p>
                                      </div>
                                    </div>
                                  ))}
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  );

                case 'home':
                default:
                  return (
                    <div ref={containerRef} className="p-8">
                      <header className="flex flex-col md:flex-row items-center justify-between gap-6 mb-8">
                        <h1 className="text-5xl font-bold text-white">Media Library</h1>
                        <div className="relative w-full max-w-lg">
                          <input
                            type="text"
                            id="search-input"
                            placeholder="Search for movies or series..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className="focusable-item w-full pl-12 pr-4 py-4 rounded-full text-xl bg-zinc-900 text-white border-2 border-zinc-700 focus:outline-none focus:border-white transition-colors"
                            tabIndex="1"
                          />
                          <Search className="h-6 w-6 absolute left-4 top-1/2 -translate-y-1/2 text-white" />
                        </div>
                      </header>

                      {loading && <div className="text-center text-4xl text-white">Loading...</div>}
                      {error && <div className="text-center text-red-500 text-4xl">{error}</div>}
                      {!loading && !error && (
                        <main className="space-y-12">
                          {filteredMovies.length > 0 && (
                            <section>
                              <h2 className="text-3xl font-semibold mb-6">Movies</h2>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-8">
                                {filteredMovies.map(movie => (
                                  <div
                                    key={movie._id}
                                    className="focusable-item group cursor-pointer rounded-lg overflow-hidden shadow-lg transition-all duration-300 bg-zinc-800 border border-transparent hover:scale-105 focus:outline-none focus:scale-105 focus:shadow-white"
                                    onClick={() => playVideo(movie.streamingUrl, { title: movie.name, thumbnail: movie.thumbnail, subtitle: 'Movie' })}
                                    tabIndex="0"
                                  >
                                    <img
                                      src={movie.thumbnail}
                                      alt={movie.name}
                                      className="w-full h-80 object-cover"
                                      onError={(e) => (e.target.src = `https://placehold.co/400x600/000000/ffffff?text=${encodeURIComponent(movie.name)}`)}
                                    />
                                    <div className="p-4">
                                      <h3 className="text-xl font-semibold truncate text-white">{movie.name}</h3>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </section>
                          )}
                          {filteredSeries.length > 0 && (
                            <section>
                              <h2 className="text-3xl font-semibold mb-6">Series</h2>
                              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-8">
                                {filteredSeries.map(seriesItem => (
                                  <div
                                    key={seriesItem._id}
                                    className="focusable-item group cursor-pointer rounded-lg overflow-hidden shadow-lg transition-all duration-300 bg-zinc-800 border border-transparent hover:scale-105 focus:outline-none focus:scale-105 focus:shadow-white"
                                    onClick={() => openSeriesModal(seriesItem)}
                                    tabIndex="0"
                                  >
                                    <img
                                      src={seriesItem.thumbnail}
                                      alt={seriesItem.name}
                                      className="w-full h-80 object-cover"
                                      onError={(e) => (e.target.src = `https://placehold.co/400x600/000000/ffffff?text=${encodeURIComponent(seriesItem.name)}`)}
                                    />
                                    <div className="p-4">
                                      <h3 className="text-xl font-semibold truncate text-white">{seriesItem.name}</h3>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </section>
                          )}
                        </main>
                      )}
                    </div>
                  );
              }
            };

            const root = createRoot(document.getElementById('root'));
            root.render(<App />);
        };
    </script>
</body>
</html>

