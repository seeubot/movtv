<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Manager TV</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Android TV remote navigation */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            overscroll-behavior-y: contain; /* Prevents scroll bounce on TV */
        }

        /* Highlight the currently focused element for remote control */
        .focusable-item:focus {
            outline: 4px solid #3b82f6; /* Blue ring for focus */
            outline-offset: 4px;
            box-shadow: 0 0 10px #3b82f6;
            transform: scale(1.05);
            transition: all 0.2s ease-in-out;
            z-index: 10;
        }

        /* Styling for the search input focus */
        #search-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        /* Backdrop for the video player modal */
        #video-player-modal {
            background-color: rgba(0, 0, 0, 0.95);
        }

        /* Custom player controls styling */
        #player-controls {
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        #player-controls button:focus, #back-button:focus {
            outline: none;
            box-shadow: 0 0 10px #ffffff;
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Hide scrollbars for a clean TV UI */
        ::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        .scrollable {
            scrollbar-width: none; /* Firefox */
        }
        
    </style>
</head>
<body class="p-8">

    <!-- Main Content Area -->
    <div id="app-container" class="space-y-12">
        
        <!-- Header with Title and Search -->
        <header class="flex flex-col md:flex-row items-center justify-between gap-6 mb-8">
            <h1 class="text-5xl font-bold text-white">Media Library</h1>
            <div class="relative w-full max-w-lg">
                <input 
                    type="text" 
                    id="search-input" 
                    placeholder="Search for movies or series..." 
                    class="focusable-item w-full pl-12 pr-4 py-4 rounded-full bg-gray-800 text-white border-2 border-gray-700 transition-colors duration-200 text-xl"
                    tabindex="1"
                >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 absolute left-4 top-1/2 -translate-y-1/2 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
            </div>
        </header>

        <!-- Loading & Error States -->
        <div id="loading" class="text-center text-4xl text-gray-500 hidden">Loading...</div>
        <div id="error-message" class="text-center text-red-500 text-4xl hidden">Failed to load data.</div>

        <!-- Movies Section -->
        <section id="movies-section" class="hidden">
            <h2 class="text-3xl font-semibold mb-6">Movies</h2>
            <div id="movies-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-8">
                <!-- Movie cards will be injected here -->
            </div>
        </section>

        <!-- Series Section -->
        <section id="series-section" class="hidden">
            <h2 class="text-3xl font-semibold mb-6">Series</h2>
            <div id="series-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-8">
                <!-- Series cards will be injected here -->
            </div>
        </section>

    </div>

    <!-- Video Player Modal -->
    <div id="video-player-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
        <div class="relative w-full h-full">
            <video id="video-player" class="w-full h-full" preload="auto" playsinline></video>
            
            <!-- Custom Player Controls and Back Button -->
            <div id="player-controls" class="absolute bottom-0 left-0 w-full p-8 flex justify-between items-center transition-opacity duration-300 opacity-0 hover:opacity-100">
                <button id="back-button" class="focusable-item p-4 rounded-full bg-gray-800 bg-opacity-70 text-white shadow-lg text-lg" tabindex="100">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                    </svg>
                </button>
                <div class="flex items-center space-x-4">
                    <button id="rewind-button" class="focusable-item p-4 rounded-full bg-gray-800 bg-opacity-70 text-white shadow-lg" tabindex="101">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l-7-7m0 0l7-7m-7 7h18" />
                        </svg>
                    </button>
                    <button id="play-pause-button" class="focusable-item p-4 rounded-full bg-blue-600 text-white shadow-lg" tabindex="102">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11l-3 1.732V7.268L15 9z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </button>
                    <button id="forward-button" class="focusable-item p-4 rounded-full bg-gray-800 bg-opacity-70 text-white shadow-lg" tabindex="103">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" />
                        </svg>
                    </button>
                </div>
                <div class="w-24"></div> <!-- Placeholder for right alignment -->
            </div>
        </div>
    </div>
    
    <!-- Episode Selection Modal -->
    <div id="series-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-gray-900 bg-opacity-90 hidden">
        <div class="relative bg-gray-800 rounded-lg p-8 max-w-4xl max-h-full overflow-y-auto scrollable">
            <button id="series-modal-close" class="focusable-item absolute top-4 right-4 text-gray-400 hover:text-white text-3xl" tabindex="200">&times;</button>
            <h2 id="series-modal-title" class="text-4xl font-bold mb-8 text-white"></h2>
            <div id="series-episodes-container" class="space-y-6">
                <!-- Episodes and seasons will be injected here -->
            </div>
        </div>
    </div>


    <script>
        // Set the API base URL from the server-side
        const API_BASE_URL = window.location.origin + '/api';

        // Get DOM elements
        const appContainer = document.getElementById('app-container');
        const loadingDiv = document.getElementById('loading');
        const errorMessageDiv = document.getElementById('error-message');
        const moviesSection = document.getElementById('movies-section');
        const moviesContainer = document.getElementById('movies-container');
        const seriesSection = document.getElementById('series-section');
        const seriesContainer = document.getElementById('series-container');
        const searchInput = document.getElementById('search-input');
        const videoPlayerModal = document.getElementById('video-player-modal');
        const videoPlayer = document.getElementById('video-player');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const rewindButton = document.getElementById('rewind-button');
        const forwardButton = document.getElementById('forward-button');
        const backButton = document.getElementById('back-button');
        const seriesModal = document.getElementById('series-modal');
        const seriesModalClose = document.getElementById('series-modal-close');
        const seriesModalTitle = document.getElementById('series-modal-title');
        const seriesEpisodesContainer = document.getElementById('series-episodes-container');
        
        // State management
        let moviesData = [];
        let seriesData = [];
        let filteredMovies = [];
        let filteredSeries = [];
        let currentFocusIndex = 0;
        let currentFocusables = [];
        
        const KEY_CODES = {
            ENTER: 13,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            BACK: 8, // Backspace key
            ESCAPE: 27
        };

        // --- Core Functions ---

        /**
         * Fetches movies and series data from the API.
         */
        async function fetchData() {
            loadingDiv.classList.remove('hidden');
            errorMessageDiv.classList.add('hidden');
            try {
                const moviesResponse = await fetch(`${API_BASE_URL}/movies`);
                const seriesResponse = await fetch(`${API_BASE_URL}/series`);

                if (!moviesResponse.ok || !seriesResponse.ok) {
                    throw new Error('Network response was not ok');
                }
                
                moviesData = await moviesResponse.json();
                seriesData = await seriesResponse.json();
                
                // Initialize filtered data with all data
                filteredMovies = moviesData;
                filteredSeries = seriesData;
                
                renderContent();

            } catch (error) {
                console.error('Fetch error:', error);
                errorMessageDiv.classList.remove('hidden');
            } finally {
                loadingDiv.classList.add('hidden');
            }
        }

        /**
         * Renders the movie and series cards to the UI.
         */
        function renderContent() {
            moviesContainer.innerHTML = '';
            seriesContainer.innerHTML = '';
            
            if (filteredMovies.length > 0) {
                moviesSection.classList.remove('hidden');
                filteredMovies.forEach(item => {
                    const card = createCard(item, 'movie');
                    moviesContainer.appendChild(card);
                });
            } else {
                moviesSection.classList.add('hidden');
            }

            if (filteredSeries.length > 0) {
                seriesSection.classList.remove('hidden');
                filteredSeries.forEach(item => {
                    const card = createCard(item, 'series');
                    seriesContainer.appendChild(card);
                });
            } else {
                seriesSection.classList.add('hidden');
            }

            // Update focusable elements after rendering
            updateFocusables();
        }

        /**
         * Creates a clickable card for a movie or series.
         * @param {object} item - The movie or series object.
         * @param {string} type - 'movie' or 'series'.
         * @returns {HTMLElement} The created card element.
         */
        function createCard(item, type) {
            const card = document.createElement('div');
            card.className = 'focusable-item group cursor-pointer rounded-lg overflow-hidden shadow-lg hover:shadow-xl transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50';
            card.setAttribute('data-id', item._id);
            card.setAttribute('data-type', type);
            card.setAttribute('tabindex', '0');

            const fallbackImage = `https://placehold.co/400x600/1f2937/d1d5db?text=${encodeURIComponent(item.name)}`;

            card.innerHTML = `
                <img src="${item.thumbnail}" alt="${item.name}" 
                     class="w-full h-80 object-cover group-hover:scale-105 transition-transform duration-300"
                     onerror="this.onerror=null;this.src='${fallbackImage}';">
                <div class="p-4">
                    <h3 class="text-xl font-semibold truncate text-white">${item.name}</h3>
                </div>
            `;
            
            card.addEventListener('click', () => handleCardClick(item));
            return card;
        }

        /**
         * Handles clicks on movie and series cards.
         * @param {object} item - The movie or series object.
         */
        function handleCardClick(item) {
            if (item.streamingUrl) {
                // It's a movie
                playVideo(item.streamingUrl);
            } else {
                // It's a series
                openSeriesModal(item);
            }
        }

        /**
         * Plays a video in the modal.
         * @param {string} url - The streaming URL.
         */
        function playVideo(url) {
            appContainer.classList.add('hidden');
            videoPlayerModal.classList.remove('hidden');
            videoPlayer.src = url;
            videoPlayer.play();
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
            
            // Set focus on the play/pause button for remote control
            playPauseButton.focus();
        }

        /**
         * Closes the video player and returns to the main view.
         */
        function closeVideoPlayer() {
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayerModal.classList.add('hidden');
            appContainer.classList.remove('hidden');
            
            // Re-focus on the last focused element or search input
            searchInput.focus();
        }
        
        /**
         * Opens the series modal to display seasons and episodes.
         * @param {object} series - The series object.
         */
        function openSeriesModal(series) {
            seriesModalTitle.textContent = series.name;
            seriesEpisodesContainer.innerHTML = '';
            
            series.seasons.sort((a, b) => a.seasonNumber - b.seasonNumber).forEach(season => {
                const seasonDiv = document.createElement('div');
                seasonDiv.className = 'border-b border-gray-700 pb-4';
                seasonDiv.innerHTML = `<h3 class="text-2xl font-bold mb-4 text-white">Season ${season.seasonNumber}</h3>`;
                
                const episodesList = document.createElement('div');
                episodesList.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4';
                
                season.episodes.sort((a, b) => a.episodeNumber - b.episodeNumber).forEach(episode => {
                    const episodeButton = document.createElement('button');
                    episodeButton.className = 'focusable-item text-left p-4 rounded-md bg-gray-700 hover:bg-gray-600 focus:bg-blue-600 focus:outline-none transition-colors duration-200';
                    episodeButton.setAttribute('tabindex', '0');
                    episodeButton.innerHTML = `
                        <div class="flex items-center space-x-4">
                            <div class="w-16 h-16 rounded-md overflow-hidden flex-shrink-0">
                                <img src="${episode.thumbnail || series.thumbnail}" alt="${episode.title}" class="w-full h-full object-cover">
                            </div>
                            <div>
                                <p class="text-lg font-semibold text-white">E${episode.episodeNumber}: ${episode.title}</p>
                                <p class="text-sm text-gray-400">Stream now</p>
                            </div>
                        </div>
                    `;
                    episodeButton.addEventListener('click', () => playVideo(episode.streamingUrl));
                    episodesList.appendChild(episodeButton);
                });
                
                seasonDiv.appendChild(episodesList);
                seriesEpisodesContainer.appendChild(seasonDiv);
            });
            
            appContainer.classList.add('hidden');
            seriesModal.classList.remove('hidden');
            seriesModalClose.focus();
        }

        /**
         * Closes the series modal and returns to the main view.
         */
        function closeSeriesModal() {
            seriesModal.classList.add('hidden');
            appContainer.classList.remove('hidden');
            searchInput.focus();
        }
        
        // --- Event Listeners and Remote Control Logic ---

        // Search input
        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            
            filteredMovies = moviesData.filter(movie => movie.name.toLowerCase().includes(query));
            filteredSeries = seriesData.filter(series => series.name.toLowerCase().includes(query));
            
            renderContent();
        });

        // Video Player Controls
        playPauseButton.addEventListener('click', () => {
            if (videoPlayer.paused) {
                videoPlayer.play();
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                videoPlayer.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
        });

        rewindButton.addEventListener('click', () => videoPlayer.currentTime -= 10);
        forwardButton.addEventListener('click', () => videoPlayer.currentTime += 10);
        backButton.addEventListener('click', closeVideoPlayer);
        seriesModalClose.addEventListener('click', closeSeriesModal);
        
        // Keydown event listener for remote control navigation
        document.addEventListener('keydown', (e) => {
            // If a video is playing, handle player controls
            if (!videoPlayerModal.classList.contains('hidden')) {
                handlePlayerKeys(e);
                return;
            }
            
            // If a series modal is open, handle modal keys
            if (!seriesModal.classList.contains('hidden')) {
                handleModalKeys(e);
                return;
            }

            // Otherwise, handle main page navigation
            handleMainPageKeys(e);
        });

        /**
         * Handles key presses for the main page (home screen).
         * @param {KeyboardEvent} e - The keydown event.
         */
        function handleMainPageKeys(e) {
            updateFocusables();
            const focusedElement = document.activeElement;
            const focusedIndex = currentFocusables.indexOf(focusedElement);
            
            switch (e.keyCode) {
                case KEY_CODES.RIGHT:
                    if (focusedIndex < currentFocusables.length - 1) {
                        currentFocusables[focusedIndex + 1].focus();
                    }
                    break;
                case KEY_CODES.LEFT:
                    if (focusedIndex > 0) {
                        currentFocusables[focusedIndex - 1].focus();
                    }
                    break;
                case KEY_CODES.DOWN:
                    // Find the next element in the row below
                    let nextRowElement = findNextRowElement(focusedElement, 1);
                    if (nextRowElement) nextRowElement.focus();
                    break;
                case KEY_CODES.UP:
                    // Find the previous element in the row above
                    let prevRowElement = findNextRowElement(focusedElement, -1);
                    if (prevRowElement) prevRowElement.focus();
                    break;
                case KEY_CODES.ENTER:
                case KEY_CODES.SPACE:
                    // Trigger click on the focused item
                    if (focusedElement && focusedElement.classList.contains('focusable-item')) {
                        focusedElement.click();
                    }
                    break;
            }
        }
        
        /**
         * Finds the next/previous element for vertical navigation.
         * @param {HTMLElement} focusedEl - The currently focused element.
         * @param {number} direction - 1 for down, -1 for up.
         * @returns {HTMLElement|null} The next focusable element.
         */
        function findNextRowElement(focusedEl, direction) {
            const container = focusedEl.closest('.grid');
            if (!container) return null;
            const items = Array.from(container.querySelectorAll('.focusable-item'));
            const focusedIndex = items.indexOf(focusedEl);
            if (focusedIndex === -1) return null;

            const rect = focusedEl.getBoundingClientRect();
            let bestMatch = null;
            let minDistance = Infinity;

            for (const item of items) {
                const itemRect = item.getBoundingClientRect();
                // Check if the item is in the target direction
                if (direction > 0 && itemRect.top > rect.bottom) {
                    const distance = Math.abs(itemRect.left - rect.left);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = item;
                    }
                } else if (direction < 0 && itemRect.bottom < rect.top) {
                    const distance = Math.abs(itemRect.left - rect.left);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = item;
                    }
                }
            }
            return bestMatch;
        }

        /**
         * Handles key presses for the video player modal.
         * @param {KeyboardEvent} e - The keydown event.
         */
        function handlePlayerKeys(e) {
            switch (e.keyCode) {
                case KEY_CODES.ENTER:
                case KEY_CODES.SPACE:
                    e.preventDefault(); // Prevents default spacebar scroll
                    playPauseButton.click();
                    break;
                case KEY_CODES.RIGHT:
                    e.preventDefault();
                    forwardButton.click();
                    break;
                case KEY_CODES.LEFT:
                    e.preventDefault();
                    rewindButton.click();
                    break;
                case KEY_CODES.BACK:
                case KEY_CODES.ESCAPE:
                    e.preventDefault();
                    closeVideoPlayer();
                    break;
                case KEY_CODES.UP:
                case KEY_CODES.DOWN:
                    // Allow navigating between player controls
                    // Currently only a few buttons, so simple logic is fine
                    if (document.activeElement === backButton || document.activeElement === playPauseButton || document.activeElement === rewindButton || document.activeElement === forwardButton) {
                        e.preventDefault(); // Prevents moving to app container in the background
                    }
                    break;
            }
        }
        
        /**
         * Handles key presses for the series modal.
         * @param {KeyboardEvent} e - The keydown event.
         */
        function handleModalKeys(e) {
            updateFocusables();
            const focusedElement = document.activeElement;
            const focusedIndex = currentFocusables.indexOf(focusedElement);
            
            switch (e.keyCode) {
                case KEY_CODES.RIGHT:
                    if (focusedIndex < currentFocusables.length - 1) {
                        currentFocusables[focusedIndex + 1].focus();
                    }
                    break;
                case KEY_CODES.LEFT:
                    if (focusedIndex > 0) {
                        currentFocusables[focusedIndex - 1].focus();
                    }
                    break;
                case KEY_CODES.DOWN:
                    const nextModalItem = findNextRowElement(focusedElement, 1);
                    if (nextModalItem) nextModalItem.focus();
                    break;
                case KEY_CODES.UP:
                    const prevModalItem = findNextRowElement(focusedElement, -1);
                    if (prevModalItem) prevModalItem.focus();
                    break;
                case KEY_CODES.ENTER:
                case KEY_CODES.SPACE:
                    if (focusedElement && focusedElement.classList.contains('focusable-item')) {
                        focusedElement.click();
                    }
                    break;
                case KEY_CODES.BACK:
                case KEY_CODES.ESCAPE:
                    e.preventDefault();
                    closeSeriesModal();
                    break;
            }
        }

        /**
         * Updates the list of focusable items in the DOM.
         */
        function updateFocusables() {
            if (!videoPlayerModal.classList.contains('hidden')) {
                currentFocusables = Array.from(videoPlayerModal.querySelectorAll('.focusable-item'));
            } else if (!seriesModal.classList.contains('hidden')) {
                currentFocusables = Array.from(seriesModal.querySelectorAll('.focusable-item'));
            } else {
                currentFocusables = Array.from(document.querySelectorAll('.focusable-item'));
            }
            // Ensure search input is always the first focusable item
            if (currentFocusables[0] !== searchInput && !videoPlayerModal.classList.contains('hidden') && !seriesModal.classList.contains('hidden')) {
                currentFocusables.unshift(searchInput);
            }
        }

        // Initial setup on page load
        window.onload = function() {
            fetchData().then(() => {
                // Initial focus on search bar after data loads
                searchInput.focus();
            });
        };
    </script>
</body>
</html>

